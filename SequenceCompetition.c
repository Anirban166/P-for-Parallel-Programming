// Author: Anirban166/Anirban Chetia
// E-mail: bloodraven166@gmail.com/ac4743@nau.edu

// Header files:
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <stdbool.h>

// Setting the number of threads plus the required number of correct sequences:
static const int threadCount = 6;
static const int requiredNumberOfCorrectSequences = 10;

// Function declarations/prototypes:
void *do_work(void *arg);
void *do_work2(void *arg);
bool createdSequence(int buffer[], int threadSet);
void clearBuffer(int *bufferPointer, int bufferSize);

// Argument struct:
struct arguments
{
  pthread_mutex_t *mutex;                // Lock for mutual exclusion which is specific to a set of threads
  int value;                             // Variable containing an integer value (one for each thread)
  int *buffer;                           // Buffer to store values (3)
  int *bufferIndex;                      // Variable to store the buffer/array index for a set of threads 
  int *threadSet1_correctSequencesCount; // Variable to count the no. of '123' sequences made by the first set of threads
  int *threadSet2_correctSequencesCount; // Variable to count the no. of '456' sequences made by the second set of threads
  int *threadSet1_totalSequencesCount;   // Variable to count the total no. of sequences (every 3 prints) made by the first set of threads
  int *threadSet2_totalSequencesCount;   // Variable to count the total no. of sequences (every 3 prints) made by the second set of threads
  bool *winCondition;                    // Variable to indicate if a set of threads made 10 correct sequences
};

// Function to check if a desired sequence (123/456) is created:
bool createdSequence(int buffer[], int threadSet)
{ 
  if(threadSet == 123)
  {
    return (buffer[0] == 1 && buffer[1] == 2 && buffer[2] == 3);
  }
  else if(threadSet == 456)
  {
    return (buffer[0] == 4 && buffer[1] == 5 && buffer[2] == 6);
  }
}

// Function to clear the buffer:
void clearBuffer(int *bufferPointer, int bufferSize)
{
    for (int i = 0; i < bufferSize; i++)
    {
        *bufferPointer = 0;
        bufferPointer++;
    }
}

// Function for the first set of threads: (123 sequence generation team)
void *do_work(void *arg)
{
  struct arguments *threadArguments = (struct arguments *)arg;
  int *indexPointer = NULL;
  int *threadSet1_correctSequencesCount = threadArguments->threadSet1_correctSequencesCount;
  int *threadSet1_totalSequencesCount = threadArguments->threadSet1_totalSequencesCount;
  int *threadSet2_correctSequencesCount = threadArguments->threadSet2_correctSequencesCount;
  int *threadSet2_totalSequencesCount = threadArguments->threadSet2_totalSequencesCount;
  bool *winCondition = threadArguments->winCondition;
  pthread_mutex_t *mutex = threadArguments->mutex;

  // Looping here till I get 10 correct sequences (123), or till the other set of threads does (456), 
  // as will be indicated by the state of the shared winCondition variable (until it remains false):
  while (*threadSet1_correctSequencesCount < requiredNumberOfCorrectSequences && !(*winCondition))
  {
    pthread_mutex_lock(mutex);
    if (*winCondition)
    {
      pthread_mutex_unlock(mutex);
      break;
    }
    indexPointer = threadArguments->bufferIndex;
    printf("My id: %d\n", threadArguments->value);
    threadArguments->buffer[*indexPointer] = threadArguments->value;
    if (*indexPointer == 2)
    {
      *threadSet1_totalSequencesCount += 1;
      if (createdSequence(threadArguments->buffer, 123))
      {
        printf("123\n");
        *threadSet1_correctSequencesCount += 1;
        // Case I: Team 1 finishes 10 correct sequences first (123):
        if (*threadSet1_correctSequencesCount == 10)
        {
          // Setting winCondition (to true) so that the other threads do not run: 
          *winCondition = true;
          printf("Team 1 won!\n");
        }
      }
      *indexPointer = 0;
      clearBuffer(threadArguments->buffer, 3);
    }
    else
    {
      *indexPointer += 1;
    }
    // Printing the total and respective correct sequences generated by each team, following Team 1's triumph:
    if (*threadSet1_correctSequencesCount == requiredNumberOfCorrectSequences && *winCondition)
    {
      printf("Total sequences generated team1: %d\n", *(threadArguments->threadSet1_totalSequencesCount));
      printf("Number of correct sequences team1: %d\n", *(threadArguments->threadSet1_correctSequencesCount));
      printf("Total sequences generated team2: %d\n", *(threadArguments->threadSet2_totalSequencesCount));
      printf("Number of correct sequences team2: %d\n", *(threadArguments->threadSet2_correctSequencesCount));
    }
    pthread_mutex_unlock(mutex);
    usleep(500000);
  }
  return NULL;
}

// Function for the second set of threads: (456 sequence generation team)
void *do_work2(void *arg)
{
  struct arguments *threadArguments = (struct arguments *)arg;
  int *indexPointer = NULL;
  int *threadSet1_correctSequencesCount = threadArguments->threadSet1_correctSequencesCount;
  int *threadSet1_totalSequencesCount = threadArguments->threadSet1_totalSequencesCount;
  int *threadSet2_correctSequencesCount = threadArguments->threadSet2_correctSequencesCount;
  int *threadSet2_totalSequencesCount = threadArguments->threadSet2_totalSequencesCount;
  bool *winCondition = threadArguments->winCondition;
  pthread_mutex_t *mutex = threadArguments->mutex;

  // Again, looping here till I get 10 correct sequences (456), or till the shared winCondition 
  // variable is false: (can be set to true by either 10 sequences of '123' or '456', whichever case occurs first)
  while (*threadSet2_correctSequencesCount < requiredNumberOfCorrectSequences && !(*winCondition))
  {
    pthread_mutex_lock(mutex);
    if (*winCondition)
    {
      pthread_mutex_unlock(mutex);
      break;
    }
    indexPointer = threadArguments->bufferIndex;
    printf("My id: %d\n", threadArguments->value);
    threadArguments->buffer[*indexPointer] = threadArguments->value;
    if (*indexPointer == 2)
    {
      *threadSet2_totalSequencesCount += 1;
      if (createdSequence(threadArguments->buffer, 456))
      {
        printf("456\n");
        // Case II: Team 2 finishes 10 correct sequences first (456):
        *threadSet2_correctSequencesCount += 1;
        if (*threadSet2_correctSequencesCount == 10)
        {
          // Likewise, setting the shared boolean here to indicate the competition is over: (and that all threads need to stop)
          printf("Team 2 won!\n");
          *winCondition = true;
        }
      }
      *indexPointer = 0;
      clearBuffer(threadArguments->buffer, 3);
    }
    else
    {
      *indexPointer += 1;
    }
    // Printing the total and respective correct sequences generated by each team, following Team 2's triumph:
    if (*threadSet2_correctSequencesCount == requiredNumberOfCorrectSequences && *winCondition)
    {
      printf("Total sequences generated team1: %d\n", *(threadArguments->threadSet1_totalSequencesCount));
      printf("Number of correct sequences team1: %d\n", *(threadArguments->threadSet1_correctSequencesCount));
      printf("Total sequences generated team2: %d\n", *(threadArguments->threadSet2_totalSequencesCount));
      printf("Number of correct sequences team2: %d\n", *(threadArguments->threadSet2_correctSequencesCount));
    }
    pthread_mutex_unlock(mutex);
    usleep(500000);
  }
  return NULL;
}

int main(int argc, char *argv)
{
    // Declaring the array of pthreads (6):
    pthread_t thread[threadCount];
    
    // Initializing shared variables:
    int bufferIndex1 = 0, bufferIndex2 = 0;
    bool winCondition = false;
    int threadSet1_correctSequencesCount = 0, threadSet2_correctSequencesCount = 0;
    int threadSet1_totalSequencesCount = 0, threadSet2_totalSequencesCount = 0;
    
    // Initializing variables specific to a set of threads: (separate buffers and locks)
    int buffer1[3] = {0, 0, 0}, buffer2[3] = {0, 0, 0};
    pthread_mutex_t buffer1Lock;
    pthread_mutex_t buffer2Lock;
    pthread_mutex_init(&buffer1Lock, NULL);
    pthread_mutex_init(&buffer2Lock, NULL);

    // Initializing the arguments struct and creating arguments for the threads:
    struct arguments *threadArguments[threadCount];
    for (int i = 0; i < threadCount; i++)
    {
        threadArguments[i] = (struct arguments *)calloc(1, sizeof(struct arguments));
        threadArguments[i]->value = i + 1;
        // Shared variables:
        threadArguments[i]->winCondition = &winCondition;
        threadArguments[i]->threadSet1_correctSequencesCount = &threadSet1_correctSequencesCount;
        threadArguments[i]->threadSet2_correctSequencesCount = &threadSet2_correctSequencesCount;        
        threadArguments[i]->threadSet1_totalSequencesCount = &threadSet1_totalSequencesCount;
        threadArguments[i]->threadSet2_totalSequencesCount = &threadSet2_totalSequencesCount;
        // Assigning arguments to each set of threads with their respective variables:
        if (i < 3)
        {
            threadArguments[i]->buffer = buffer1;
            threadArguments[i]->mutex = &buffer1Lock;
            threadArguments[i]->bufferIndex = &bufferIndex1;
        }
        else
        {
            threadArguments[i]->buffer = buffer2;
            threadArguments[i]->mutex = &buffer2Lock;
            threadArguments[i]->bufferIndex = &bufferIndex2;
        }
    }

    // Creating the first set of three threads: (with appropriate arguments passed on to the do_work function)
    for (int t = 0; t < (threadCount/2); t++) 
    {
      if (pthread_create(&thread[t], NULL, do_work, (void *)threadArguments[t])) 
      {
        fprintf(stderr, "Error while creating thread #%d!\n",t);
        exit(1);
      }
    }

    // Creating the second set of three threads: (with appropriate arguments passed on to the do_work2 function)
    for (int t = (threadCount/2); t < threadCount; t++) 
    {
      if (pthread_create(&thread[t], NULL, do_work2, (void *)threadArguments[t])) 
      {
        fprintf(stderr, "Error while creating thread #%d!\n",t);
        exit(1);
      }
    }

    // Joining them:
    for (int t = 0; t < threadCount; t++) 
    {
      if (pthread_join(thread[t], NULL)) 
      {
        fprintf(stderr, "Error while joining the threads!\n");
        exit(1);
      }  
    }
    
    // Unitializing the mutex locks:
    pthread_mutex_destroy(&buffer1Lock);
    pthread_mutex_destroy(&buffer2Lock);

    // Exiting the program (without any errors):
    exit(0);
}
